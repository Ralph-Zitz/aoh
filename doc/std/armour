OBJECT
	armour

LAST UPDATE
	Thragor, 21 Jan 1997, 17:30:00 MET

SYNOPSIS
	inherit "std/armour";

	#include <properties.h>
	#include <combat.h>


DESCRIPTION
	This is the general class for all conventional armours.
	It is a descendant of /std/thing and /std/equipment with the
	combat functionality added.

	To be useful for combat, the armour must be worn. Dropping
	or destructing the armour also unwears it.

	/std/armour implements the following additional properties:

	- P_DEFENCES	: an array of the defence capabilities.
	- P_AC		: the basic class of this armour - setting this
			  clears all special defences.
	- P_ARMOUR_TYPE : the type of this armour - must be one of
			  the AT_xxx from /sys/combat.h
	- P_AP_PER_QP	: This value allows you to reduce the quality of your
			  armour.
			  Armour quality ranges from 0-100%. A armour's
			  percentage of quality will be reduced as follows:
			  From each hit done by an attacker's weapon, a certain
			  amount is absorbed by the armour. If the amount
			  of damage absorbed is more than twice the number
			  defined in P_AP_PER_QP, the amount of absorbed damage
			  is divided by P_AP_PER_QP. The result is subtracted
			  from the overall percentage of quality of the armour.

			  Example: P_AP_PER_QP is set to 5. An attacker's hit
			    to the armour does 30 points of damage, but 20 of
			    that is absorbed by the armour. 20 divided by 5
			    is 4, so the armour degrades in quality by 4%.


	The following armour types are defined:

	  AT_ARMOUR, AT_HELMET, AT_AMULET, AT_RING,
	  AT_CLOAK, AT_BOOTS, AT_SHIELD.

	whereas each of the types describes a whole class.

	The protection of an armour is dependant on the attack.
	There is a basic protection AC against any attack. Against
	a DT_INTR attack it is also the only protection.
	(Note: weapons are not suposed to do damage of type DT_INTR,
	use DT_SLASH, DT_BLUDGEON, DT_PIERCE instead, like the
	std/weapon does.)
	Then for each of the possible damage types DT_xxx the armour
	may offer special (un)protection. In combat, the special protection
	plus the basic protection gives the overall protection.

	The protection capabilities are stored in the array P_DEFENCES.
	It's elements are indexed by the DT_xxx values.
	The first value, DT_INTR alias AC, always exist. The others
	might exist - if not, they are treated as being 0.

	The armour may be configured (besides the normal /std/thing-calls)
	with:

	SetArmourType (string armour_type)
	  Sets the type to <armour_type>. This also adds an corresponding
	  id.

	SetAC (int ac)
	  Sets the basic protection to <ac>. This also clears any special
	  protection.

	SetDefence (int damage_type, int value)
	  Set the protection against the given <damage_type> to <value>.
	  This allows step-by-step configuration of P_DEFENCES.

	int SetStandard (string armour_type, int ac, int size)
	  Configures the armour as a standard armour of given <armour_type>
	  and class <ac>.
	  Size is used to calculate the weight and also automatically
	  set in the weapon.
	  It sets description, weight, value, AT, and AC(!).
	  If <armour_type> is illegal, 0 is returned, else 1.
	  If you need to use SetStandard() with SetProperties() you
	  may give an array as first argument, which looks like this:
	    ({ armour_type [, ac [, size] ] }).
	  E. g. you may call:
	    armour->SetStandard(({AT_ARMOUR,4,PSIZE_NORMAL}));

	Following funs are also of interest:

	mixed Defend (object enemy, int damage, int damage_type)
	  This is called by <enemy> which is trying to do us <damage> hp
	  of damage with a <damage_type> attack.
	  This fun shall return the protection, which is then subtracted
	  from <damage> by the enemy.
	  If set, defendobject->DefendHit() is called and returned,
	  else CalcDefend().

	  The return value can be either an int that gives the defence
	  value, or a two-element array, that consists of an defence
	  value and a string, that will be told to the room after all
	  the `Foo hits Bar with a bone crushing sound' messages are
	  written. These messages are automagically generated by
	  /std/living/combat for the three `conventional' damage types
	  DT_SLASH, DT_BLUDGEON, DT_PIERCE . In that cases, the armour
	  must not write any messages itself, but use the
	  return-an-array method. For non-conventional damage types,
	  the living/combat cannot generate messages itself, so the
	  armour can do simple say()'s and write()'s.
	  ----> This will change in near future. The armour is free
	  ----> to say() and write() arbitrary messages in the Defend()
	  ----> function. These messages will appear before the
	  ----> `Foo hits Bar with a bone crushing sound' messages
	  ----> from the battle round. Along with these will go
	  ----> a significant reduction of battle noise.

	int CalcDefend (object enemy, int damage, int damage_type)
	  Return the protection this armour gives against the attack.
	  If is calculated by some magic formula.


	The following functions exist for compatibility only.

	SetDefendObj (ob)
	  Sets the defendobject to <ob>.
	  If the armour is hit, and a defendobject is specified,
	  defendobject->DefendHit (enemy, damage, damage_type)	is called
	  and the result is the given protection.
	  <enemy> is the attacking enemy, <damage> the damage it want
	  to give us, and <damage_type> the type of attack.

	SetWearObj (ob)
	  Sets the weardobject to <ob>.
	  If the armour is worn, and a wearobject specified,
	  wearobject->CheckWear (wielder) is done. If it returns 0,
	  the armour is not worn.

	SetRemoveObj (ob)
	  Sets the removeobject to <ob>.
	  If the armour is removed, and an removeobject specified,
	  removeobject->CheckRemove (wielder) is done. If it returns 0,
	  the armour is not removed.


INHERITANCE TREE
	armour
	  |-armour/combat
	  |   `-std/equipment
	  `-thing
	      |-thing/moving
	      |-thing/cleaning
	      |-thing/properties
	      `-thing/description


SEE ALSO
	equipment(S), weapon(C), ac(C), living(C), thing(S), properties(C)
